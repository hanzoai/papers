\documentclass[11pt,twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{cite}

\title{\textbf{Hanzo Network: A Decentralized AI Compute Platform with Post-Quantum Security and Physics-Inspired LLM Routing}}

\author{
Zach Kelling\thanks{Corresponding author: zach@lux.network} \\
\textit{Hanzo Industries \quad Lux Industries \quad Zoo Labs Foundation} \\
\texttt{research@lux.network}
}

\date{Version: v2025.09 \\ September 2025}

\begin{document}

\maketitle

\begin{abstract}
We present Hanzo Network, a decentralized compute platform that integrates blockchain consensus, confidential computing, and advanced AI inference routing into a unified architecture. The system introduces four core innovations: (1) \textbf{HLLM (Hamiltonian Hidden-Markov LLM)}, a physics-inspired routing framework that combines regime detection with Hamiltonian dynamics for optimal model selection; (2) \textbf{Post-Quantum Cryptography (PQC)} integration with NIST FIPS 203/204 compliance and five-tier privacy model supporting GPU TEE-I/O; (3) \textbf{Unified Runtime Abstraction} enabling seamless orchestration across Docker, Kubernetes, WASM, and Firecracker runtimes; and (4) \textbf{Compute DEX (Decentralized Exchange)} with on-chain resource accounting and AI token mining. Benchmarks demonstrate 9M+ blocks/second consensus throughput with sub-100μs PQC operations. The system supports 20+ LLM providers, native Qwen3 embeddings with 4096 dimensions, and blockchain-integrated compute metering. This architecture enables practical decentralized AI infrastructure with quantum-safe security guarantees.
\end{abstract}

\section{Introduction}

The convergence of artificial intelligence and decentralized systems presents unprecedented opportunities for democratizing compute access while maintaining security and privacy guarantees. However, existing platforms face critical challenges: (1) centralized control over AI inference resources, (2) lack of quantum-resistant security in production systems, (3) fragmented runtime environments requiring manual orchestration, and (4) absence of fair resource pricing mechanisms.

Hanzo Network addresses these challenges through a novel integration of blockchain consensus, confidential computing, and adaptive AI routing. The system was first deployed in September 2025 with over 4,500 commits representing continuous development and refinement.

\subsection{Key Contributions}

\begin{enumerate}
\item \textbf{HLLM Routing Framework}: Physics-inspired model selection combining Hidden Markov Models for regime detection with Hamiltonian mechanics for price dynamics and BitDelta quantization for efficient adaptation.

\item \textbf{Production PQC Implementation}: NIST-compliant ML-KEM (FIPS 203) and ML-DSA (FIPS 204) with hybrid classical/quantum modes, supporting GPU Confidential Computing on H100/Blackwell architectures.

\item \textbf{Unified Runtime Abstraction}: Protocol-agnostic interface for Docker, Kubernetes, WASM, and Firecracker with blockchain-integrated compute metering and automatic billing.

\item \textbf{Lux Consensus Integration}: High-throughput consensus (9M+ blocks/second) with sled database backend and native compute scheduling daemon.

\item \textbf{Native Qwen3 Support}: First-class integration of Qwen3-Embedding-8B (4096-dim) and Qwen3-Reranker-4B models with GPU-accelerated inference via mistral.rs.
\end{enumerate}

\section{System Architecture}

Hanzo Network implements a layered architecture separating consensus, compute orchestration, and AI inference concerns while maintaining tight integration for performance.

\subsection{Core Components}

\subsubsection{Node Architecture}

The Hanzo node consists of 25+ Rust crates organized into functional layers:

\begin{itemize}
\item \textbf{Consensus Layer} (\texttt{hanzo-consensus}): Lux/Avalanche Snow family consensus with sled database backend
\item \textbf{Runtime Layer} (\texttt{hanzo-runtime}): Unified abstraction for Docker/K8s/WASM/Firecracker
\item \textbf{Cryptography Layer} (\texttt{hanzo-pqc}, \texttt{hanzo-kbs}): Post-quantum KEM/DSA with Key Broker Service
\item \textbf{AI Layer} (\texttt{hanzo-hllm}, \texttt{hanzo-embedding}): Routing and inference coordination
\item \textbf{Network Layer} (\texttt{hanzo-libp2p-relayer}): P2P networking with relay support
\item \textbf{API Layer} (\texttt{hanzo-http-api}): REST/WebSocket/SSE endpoints
\end{itemize}

\subsubsection{Port Configuration}

\begin{itemize}
\item \textbf{3690}: Main HTTP/WebSocket API
\item \textbf{3691}: P2P networking port
\item \textbf{3692}: Server-Sent Events (SSE) streaming
\item \textbf{36900}: Hanzo Engine inference service
\item \textbf{9650-9651}: Consensus RPC endpoints
\end{itemize}

\section{HLLM: Physics-Inspired LLM Routing}

The Hamiltonian Hidden-Markov LLM (HLLM) framework introduces a novel approach to model selection by treating inference routing as a physical system with conserved quantities and regime transitions.

\subsection{Theoretical Foundation}

\subsubsection{Regime Detection via HMM}

The system models user interaction patterns as a Hidden Markov Model with four primary regimes:

\begin{equation}
\mathcal{R} = \{\text{Exploration}, \text{Exploitation}, \text{Crisis}, \text{Transition}\}
\end{equation}

State transitions follow the Markov property:

\begin{equation}
P(r_{t+1} = j | r_t = i, r_{t-1}, \ldots) = P(r_{t+1} = j | r_t = i) = A_{ij}
\end{equation}

where $A$ is the transition matrix learned from historical observations.

\subsubsection{Hamiltonian Dynamics}

Price dynamics for model selection follow Hamiltonian mechanics:

\begin{equation}
H(q, p, t) = T(p) + V(q, t)
\end{equation}

where:
\begin{itemize}
\item $q$: Model configuration space (quality, latency)
\item $p$: Momentum (pricing pressure)
\item $T(p) = \frac{p^2}{2m}$: Kinetic energy (market dynamics)
\item $V(q,t)$: Potential energy (intrinsic model costs)
\end{itemize}

Hamilton's equations govern system evolution:

\begin{align}
\frac{dq}{dt} &= \frac{\partial H}{\partial p} \\
\frac{dp}{dt} &= -\frac{\partial H}{\partial q}
\end{align}

This formulation ensures energy conservation and prevents pricing instabilities.

\subsubsection{Expected Free Energy Minimization}

Model selection minimizes Expected Free Energy (EFE) from active inference:

\begin{equation}
\mathcal{G}(\pi) = \mathbb{E}_{Q(\tilde{o}, \tilde{s}|\pi)} \left[ \log Q(\tilde{s}|\pi) - \log P(\tilde{o}, \tilde{s}) \right]
\end{equation}

where:
\begin{itemize}
\item $\pi$: Routing policy
\item $\tilde{o}$: Future observations
\item $\tilde{s}$: Future states
\item $Q(\tilde{s}|\pi)$: Belief distribution under policy $\pi$
\item $P(\tilde{o}, \tilde{s})$: Generative model
\end{itemize}

Decomposing EFE into epistemic and pragmatic values:

\begin{equation}
\mathcal{G}(\pi) = \underbrace{\mathbb{E}_{Q(\tilde{o}|\pi)}[D_{KL}[Q(\tilde{s}|\tilde{o}, \pi)||Q(\tilde{s}|\pi)]]}_{\text{Epistemic value (information gain)}} - \underbrace{\mathbb{E}_{Q(\tilde{o}|\pi)}[\log P(\tilde{o})]}_{\text{Pragmatic value (preference)}}\end{equation}

\subsection{BitDelta Quantization}

User-specific adapters use 1-bit quantization inspired by BitDelta \cite{bitdelta}:

\begin{equation}
\Delta W = \text{sign}(W_{\text{full}} - W_{\text{base}}) \cdot \alpha
\end{equation}

where $\alpha$ is a learned scaling factor. This achieves $32\times$ compression with minimal quality loss.

\subsection{Implementation}

The HLLM system (\texttt{crates/hanzo-hllm/}) implements:

\begin{algorithm}
\caption{HLLM Routing Decision}
\begin{algorithmic}[1]
\REQUIRE User ID, Request, Observations
\ENSURE Routing Decision
\STATE Detect regime $r \leftarrow$ HMM.detect(observations)
\STATE Get user adapter $A_u \leftarrow$ AdapterManager.get(user\_id)
\STATE Compute phase space $\Phi \leftarrow$ Hamiltonian(regime, adapter)
\STATE Calculate EFE $\mathcal{G} \leftarrow$ FreeEnergy($r$, $A_u$, request)
\STATE Select model $m^* \leftarrow \arg\min_{m} \mathcal{G}(\pi_m)$
\STATE Update adapter $A_u \leftarrow$ BitDelta.update($A_u$, decision)
\RETURN RoutingDecision($m^*$, regime, EFE)
\end{algorithmic}
\end{algorithm}

Key features:
\begin{itemize}
\item Sled database backend for persistent storage
\item Vector index for semantic search (768-dim embeddings)
\item LRU cache for hot adapters (default: 100 entries)
\item Async Rust implementation with Tokio runtime
\end{itemize}

\section{Post-Quantum Cryptography}

Hanzo implements production-ready PQC compliant with NIST FIPS 203/204 standards, addressing the threat of quantum computers to current cryptographic systems.

\subsection{Algorithm Selection}

\subsubsection{ML-KEM (FIPS 203)}

Module-Lattice Key Encapsulation Mechanism:

\begin{itemize}
\item \textbf{ML-KEM-512}: 128-bit security, lightweight IoT
\item \textbf{ML-KEM-768}: 192-bit security, \textbf{default}
\item \textbf{ML-KEM-1024}: 256-bit security, maximum protection
\end{itemize}

Key sizes (ML-KEM-768):
\begin{itemize}
\item Encapsulation key: 1184 bytes
\item Decapsulation key: 2400 bytes
\item Ciphertext: 1088 bytes
\item Shared secret: 32 bytes
\end{itemize}

\subsubsection{ML-DSA (FIPS 204)}

Module-Lattice Digital Signature Algorithm:

\begin{itemize}
\item \textbf{ML-DSA-44}: 128-bit security, fast verification
\item \textbf{ML-DSA-65}: 192-bit security, \textbf{default}
\item \textbf{ML-DSA-87}: 256-bit security, maximum protection
\end{itemize}

Signature sizes (ML-DSA-65):
\begin{itemize}
\item Verification key: 1952 bytes
\item Signing key: 4032 bytes
\item Signature: 3309 bytes (deterministic)
\end{itemize}

\subsection{Privacy Tiers}

Hanzo implements a five-tier privacy model with automatic algorithm selection:

\begin{table}[h]
\centering
\small
\begin{tabular}{|c|l|c|c|}
\hline
\textbf{Tier} & \textbf{Environment} & \textbf{ML-KEM} & \textbf{ML-DSA} \\
\hline
0 & Open Data & 768 & 65 \\
1 & At-Rest Encryption & 768 & 65 \\
2 & CPU TEE & 768 & 65 \\
3 & GPU CC (H100) & 1024 & 87 \\
4 & GPU TEE-I/O & 1024 & 87 \\
\hline
\end{tabular}
\caption{Privacy tier algorithm selection}
\label{tab:privacy_tiers}
\end{table}

Tier 3/4 support NVIDIA H100 Confidential Computing and Blackwell TEE-I/O with:
\begin{itemize}
\item Encrypted DMA transfers
\item NVLink security
\item Attestation-based key release
\item Hardware-backed enclave protection
\end{itemize}

\subsection{Hybrid Mode}

Defense-in-depth via combined PQC + classical crypto:

\begin{equation}
K_{\text{shared}} = \text{KDF}(K_{\text{ML-KEM}} \parallel K_{\text{X25519}})
\end{equation}

Using HKDF (SP 800-56C compliant):

\begin{equation}
\text{KDF}(IKM, salt, info, L) = \text{HKDF-Expand}(\text{HKDF-Extract}(salt, IKM), info, L)
\end{equation}

This protects against both classical and quantum attacks, with security level $\max(\text{ML-KEM}, \text{X25519})$.

\subsection{Key Broker Service (KBS)}

Attestation-based key release (\texttt{hanzo-kbs}):

\begin{algorithm}
\caption{PQC-Enhanced Key Release}
\begin{algorithmic}[1]
\REQUIRE TEE attestation report, privacy tier
\ENSURE Wrapped DEK (Data Encryption Key)
\STATE Verify TEE attestation signature
\STATE Check attestation measurements against policy
\STATE Select KEK (Key Encryption Key) based on tier
\IF{tier $\geq$ 3}
    \STATE Use ML-KEM-1024 with GPU CC vault
\ELSE
    \STATE Use ML-KEM-768 with standard vault
\ENDIF
\STATE Generate ephemeral keypair $(pk, sk)$
\STATE Encapsulate: $(ct, ss) \leftarrow$ ML-KEM.Encap$(pk)$
\STATE Derive KEK $\leftarrow$ HKDF$(ss)$
\STATE Wrap DEK with ChaCha20Poly1305-KEK
\RETURN $(ct, \text{wrapped\_DEK})$
\end{algorithmic}
\end{algorithm}

\subsection{Performance Benchmarks}

Measured on Apple M2 Max (12-core CPU):

\begin{table}[h]
\centering
\small
\begin{tabular}{|l|c|c|}
\hline
\textbf{Operation} & \textbf{ML-KEM-768} & \textbf{ML-DSA-65} \\
\hline
Keygen & 47 μs & 98 μs \\
Encap/Sign & 58 μs & 241 μs \\
Decap/Verify & 71 μs & 117 μs \\
\hline
\end{tabular}
\caption{PQC operation latencies}
\label{tab:pqc_perf}
\end{table}

These timings enable real-time encryption/signing for high-throughput workloads.

\section{Unified Runtime Abstraction}

\subsection{Design Principles}

The runtime layer (\texttt{hanzo-runtime}) provides a unified interface across heterogeneous execution environments:

\begin{lstlisting}[language=Rust, basicstyle=\small\ttfamily]
pub trait Runtime: Send + Sync {
    async fn deploy(&self, config: DeploymentConfig)
        -> Result<DeploymentId>;
    async fn stop(&self, id: &DeploymentId)
        -> Result<()>;
    async fn scale(&self, id: &DeploymentId,
        replicas: u32) -> Result<()>;
    async fn get_metrics(&self, id: &DeploymentId)
        -> Result<Metrics>;
}
\end{lstlisting}

\subsection{Supported Runtimes}

\subsubsection{Docker}

Direct integration via Bollard client:
\begin{itemize}
\item Image pull from registries
\item Volume management
\item Network configuration
\item Resource limits (CPU/memory/GPU)
\item Blockchain-integrated compute tracking
\end{itemize}

\subsubsection{Kubernetes}

Native K8s API integration:
\begin{itemize}
\item Manifest/Helm/Kustomize deployments
\item HPA (Horizontal Pod Autoscaler) support
\item Service mesh compatibility
\item GPU scheduling (NVIDIA device plugin)
\item Cost allocation per namespace
\end{itemize}

\subsubsection{WASM}

WasmEdge runtime for lightweight functions:
\begin{itemize}
\item Sub-millisecond cold start
\item Sandboxed execution
\item WASI support
\item 10x lower resource overhead vs. containers
\end{itemize}

\subsubsection{Firecracker}

MicroVM support for secure multi-tenancy:
\begin{itemize}
\item Hardware virtualization
\item Per-VM isolation
\item Minimal attack surface
\item Fast boot times ($<$125ms)
\end{itemize}

\subsection{Compute Metering}

Blockchain-native resource accounting:

\begin{equation}
\text{Compute Units} = \text{CPU} \times 10 + \text{Memory}_{\text{GB}} \times 5 + \text{GPU} \times 100
\end{equation}

Runtime-specific multipliers:
\begin{itemize}
\item Docker: $1.0\times$ (baseline)
\item Kubernetes: $1.1\times$ (orchestration overhead)
\item WASM: $0.5\times$ (efficiency bonus)
\item Firecracker: $1.15\times$ (isolation overhead)
\end{itemize}

TEE bonus multipliers:
\begin{itemize}
\item CPU TEE: $1.5\times$
\item GPU CC: $2.0\times$
\end{itemize}

Token mining rate:
\begin{equation}
\text{Tokens per hour} = \text{Compute Units} \times 10
\end{equation}

Validator payments:
\begin{equation}
\text{Validator reward} = \text{Compute cost} \times 0.10
\end{equation}

\section{Consensus and State Management}

\subsection{Lux/Avalanche Integration}

Hanzo integrates the Lux consensus engine (Snow family) with sled database backend for high-throughput finality.

\subsubsection{Snow Consensus}

Key parameters:
\begin{itemize}
\item Sample size $k = 20$
\item Quorum size $\alpha = 15$ ($75\%$ threshold)
\item Decision threshold $\beta = 20$ consecutive successes
\item Confidence threshold: 32 blocks for finality
\end{itemize}

\subsubsection{Sled Database}

Lock-free embedded database with:
\begin{itemize}
\item Atomic operations via Compare-And-Swap
\item Zero-copy reads
\item Optimized for SSD workloads
\item Built-in CRDT support for distributed state
\end{itemize}

Performance characteristics:
\begin{itemize}
\item Local throughput: 9M+ blocks/second
\item Write latency: sub-millisecond (SSD)
\item Read latency: microseconds (hot cache)
\item Storage efficiency: $<$1KB per block header
\end{itemize}

\subsection{Scheduler Daemon}

On-node compute scheduling with blockchain integration:

\begin{algorithm}
\caption{Scheduler Daemon Main Loop}
\begin{algorithmic}[1]
\STATE Initialize ResourcePool with node capacity
\LOOP
    \STATE pending $\leftarrow$ FetchPendingDeployments()
    \FORALL{deployment $d$ in pending}
        \IF{ResourcePool.CanAllocate($d$.requirements)}
            \STATE Allocate resources
            \STATE runtime.deploy($d$)
            \STATE RecordToBlockchain($d$.id, timestamp)
        \ELSE
            \STATE Enqueue($d$) for next cycle
        \ENDIF
    \ENDFOR
    \STATE CollectMetrics()
    \IF{block\_number $\mod$ billing\_interval $= 0$}
        \STATE ProcessBilling()
        \STATE MintTokens()
    \ENDIF
    \STATE Sleep(block\_time)
\ENDLOOP
\end{algorithmic}
\end{algorithm}

\section{AI Inference Integration}

\subsection{Qwen3 Native Embeddings}

First-class support for Qwen3 models:

\subsubsection{Qwen3-Embedding-8B}

Specifications:
\begin{itemize}
\item Parameters: 8 billion
\item Dimensions: 4096
\item Context: 32,768 tokens
\item MTEB Score: \#1 multilingual (pending)
\item Quantization: Q4K, Q8\_0 (GGUF)
\end{itemize}

\subsubsection{Qwen3-Reranker-4B}

Specifications:
\begin{itemize}
\item Parameters: 4 billion
\item Output: 768-dim relevance scores
\item Context: 8,192 tokens
\item Use case: Two-stage retrieval
\end{itemize}

\subsection{Inference Backends}

\subsubsection{Hanzo Engine}

Custom inference server (mistral.rs fork) on port 36900:

\begin{itemize}
\item OpenAI-compatible API
\item GPU acceleration (CUDA/Metal)
\item GGUF model support
\item ISQ (In-Situ Quantization)
\item Flash Attention support
\end{itemize}

\subsubsection{Multi-Provider Support}

20+ LLM providers via unified interface:
\begin{itemize}
\item OpenAI (GPT-4, GPT-3.5)
\item Anthropic (Claude 3 Opus/Sonnet/Haiku)
\item Google (Gemini Pro/Flash)
\item Ollama (local models)
\item Groq (high-speed inference)
\item DeepSeek (reasoning models)
\item Together AI, OpenRouter, Exo, Grok
\end{itemize}

\subsection{Embedding Pipeline}

\begin{algorithm}
\caption{Native Embedding Generation}
\begin{algorithmic}[1]
\REQUIRE Text input, model type
\ENSURE Embedding vector
\IF{USE\_NATIVE\_EMBEDDINGS $=$ true}
    \STATE Load GGUF model (Qwen3-Embedding-8B)
    \IF{GPU available}
        \STATE Initialize CUDA/Metal backend
    \ENDIF
    \STATE embedding $\leftarrow$ Model.encode(text)
    \IF{encoding fails}
        \STATE Fallback to Ollama server
    \ENDIF
\ELSE
    \STATE embedding $\leftarrow$ OllamaClient.embed(text)
\ENDIF
\RETURN embedding
\end{algorithmic}
\end{algorithm}

Performance:
\begin{itemize}
\item Throughput: 1000+ embeddings/sec (GPU)
\item Latency: $<$10ms per embedding (batch size 32)
\item Memory: 16GB VRAM for 8B model
\end{itemize}

\section{UNIX-Style API}

Inspired by UNIX philosophy and RENDER network, Hanzo exposes root-level operational endpoints:

\begin{itemize}
\item \texttt{/ps} - List all processes across runtimes
\item \texttt{/logs/<id>} - Stream workload logs
\item \texttt{/exec/<id>} - Execute commands in containers
\item \texttt{/stop/<id>}, \texttt{/kill/<id>}, \texttt{/rm/<id>} - Process control
\item \texttt{/deploy} - Deploy new workload
\item \texttt{/scale/<id>} - Scale replicas
\item \texttt{/inspect/<id>} - Get detailed state
\item \texttt{/stats}, \texttt{/health}, \texttt{/metrics} - Monitoring
\end{itemize}

This design enables:
\begin{enumerate}
\item Unified interface across heterogeneous runtimes
\item Composability via standard UNIX pipes
\item Scripting and automation
\item Intuitive mental model for developers
\end{enumerate}

\section{Security Analysis}

\subsection{Threat Model}

Hanzo addresses three threat categories:

\subsubsection{Quantum Threats}

\begin{itemize}
\item \textbf{Harvest now, decrypt later}: Adversary records encrypted traffic for future quantum decryption
\item \textbf{Key compromise}: Quantum computer breaks classical ECDH/RSA keys
\item \textbf{Signature forgery}: Quantum attacks on ECDSA signatures
\end{itemize}

Mitigations:
\begin{itemize}
\item ML-KEM-768/1024 for key establishment
\item ML-DSA-65/87 for digital signatures
\item Hybrid mode for defense-in-depth
\end{itemize}

\subsubsection{Confidential Computing}

\begin{itemize}
\item \textbf{TEE side channels}: Cache timing, speculative execution
\item \textbf{Memory snooping}: DMA attacks on unencrypted GPU memory
\item \textbf{Attestation bypass}: Forged measurements
\end{itemize}

Mitigations:
\begin{itemize}
\item Privacy tier 4: GPU TEE-I/O with encrypted NVLink
\item KBS attestation verification
\item DEK wrapping with ML-KEM
\end{itemize}

\subsubsection{Network Attacks}

\begin{itemize}
\item \textbf{Eclipse attacks}: Isolate node from honest peers
\item \textbf{Sybil attacks}: Create multiple fake identities
\item \textbf{DDoS}: Overwhelm node resources
\end{itemize}

Mitigations:
\begin{itemize}
\item LibP2P peer discovery with reputation
\item Snow consensus quorum requirements
\item Rate limiting on API endpoints
\end{itemize}

\subsection{Formal Verification}

Future work includes:
\begin{itemize}
\item TLA+ specification of consensus protocol
\item Coq proofs for PQC key derivation
\item CAVP validation for FIPS algorithms
\end{itemize}

\section{Performance Evaluation}

\subsection{Experimental Setup}

Hardware:
\begin{itemize}
\item CPU: AMD EPYC 7763 (64 cores)
\item GPU: NVIDIA H100 80GB
\item Memory: 512GB DDR4
\item Storage: NVMe SSD (Gen4)
\item Network: 100Gbps
\end{itemize}

Software:
\begin{itemize}
\item OS: Ubuntu 22.04 LTS
\item Rust: 1.75.0
\item Docker: 24.0.7
\item Kubernetes: 1.28
\end{itemize}

\subsection{Consensus Throughput}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Configuration} & \textbf{Blocks/sec} & \textbf{Finality} \\
\hline
Single node (local) & 9,200,000 & Immediate \\
3 nodes (LAN) & 45,000 & 2.1s \\
10 nodes (LAN) & 12,000 & 3.8s \\
50 nodes (WAN) & 3,500 & 8.2s \\
\hline
\end{tabular}
\caption{Consensus throughput under different topologies}
\label{tab:consensus}
\end{table}

\subsection{PQC Overhead}

\begin{table}[h]
\centering
\small
\begin{tabular}{|l|c|c|}
\hline
\textbf{Operation} & \textbf{Classical} & \textbf{PQC} \\
\hline
Key agreement & 0.12 ms & 0.13 ms \\
Signature gen & 0.08 ms & 0.24 ms \\
Signature verify & 0.09 ms & 0.12 ms \\
\hline
\end{tabular}
\caption{Classical (X25519/Ed25519) vs PQC latency}
\label{tab:pqc_overhead}
\end{table}

PQC adds negligible overhead ($<$0.2ms) compared to network latencies (typically 10-100ms).

\subsection{Runtime Performance}

\begin{table}[h]
\centering
\small
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Runtime} & \textbf{Cold Start} & \textbf{Memory} & \textbf{CPU} \\
\hline
Docker & 2.3s & 512MB & 0.5 cores \\
Kubernetes & 4.1s & 768MB & 0.6 cores \\
WASM & 8ms & 64MB & 0.1 cores \\
Firecracker & 124ms & 128MB & 0.3 cores \\
\hline
\end{tabular}
\caption{Runtime cold start and resource consumption}
\label{tab:runtime_perf}
\end{table}

\subsection{HLLM Routing Latency}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Component} & \textbf{Latency} \\
\hline
Regime detection & 0.8 ms \\
Adapter retrieval & 0.3 ms \\
EFE calculation & 1.2 ms \\
Model selection & 0.5 ms \\
\textbf{Total routing overhead} & \textbf{2.8 ms} \\
\hline
\end{tabular}
\caption{HLLM routing latency breakdown}
\label{tab:hllm_latency}
\end{table}

\subsection{Embedding Performance}

\begin{table}[h]
\centering
\small
\begin{tabular}{|l|c|c|}
\hline
\textbf{Model} & \textbf{Throughput} & \textbf{Latency} \\
\hline
Qwen3-8B (GPU) & 1,200 emb/s & 8.3 ms \\
Qwen3-8B (CPU) & 45 emb/s & 222 ms \\
Qwen3-4B (GPU) & 2,100 emb/s & 4.8 ms \\
Ollama remote & 180 emb/s & 55 ms \\
\hline
\end{tabular}
\caption{Embedding generation performance (batch=32)}
\label{tab:embedding_perf}
\end{table}

\section{Related Work}

\subsection{Decentralized Compute}

\textbf{Golem Network} \cite{golem}: Decentralized CPU/GPU marketplace using Ethereum smart contracts. Lacks quantum-safe security and AI-native routing.

\textbf{Render Network} \cite{render}: GPU rendering on blockchain. Inspired Hanzo's compute unit accounting but limited to graphics workloads.

\textbf{Akash Network} \cite{akash}: Kubernetes deployment marketplace. No PQC support, no AI-specific optimizations.

\subsection{Post-Quantum Cryptography}

\textbf{liboqs} \cite{liboqs}: Open Quantum Safe project providing NIST algorithm implementations. Hanzo builds on liboqs-rust with production integration.

\textbf{AWS PQ-TLS} \cite{awspqtls}: Hybrid TLS with post-quantum KEMs. Limited to transport layer, not application-level key management.

\subsection{AI Model Routing}

\textbf{Anyscale} \cite{anyscale}: Ray-based model serving with autoscaling. No blockchain integration, centralized control.

\textbf{Baseten} \cite{baseten}: Multi-model inference platform. Lacks physics-inspired routing and user-specific adaptation.

\subsection{Confidential Computing}

\textbf{Azure Confidential Computing} \cite{azurecc}: TEE-based VM offering. No post-quantum key management.

\textbf{NVIDIA H100 CC} \cite{h100cc}: GPU TEE with encrypted memory. Hanzo integrates this as privacy tier 3.

\section{Discussion}

\subsection{Design Trade-offs}

\subsubsection{PQC Key Sizes}

ML-KEM/ML-DSA keys are $5-10\times$ larger than classical counterparts, increasing storage and bandwidth. However, this is acceptable given:
\begin{itemize}
\item Keys are generated infrequently
\item Storage is cheap ($<$\$0.01/GB/month)
\item Quantum threat timeline (5-15 years) justifies overhead
\end{itemize}

\subsubsection{Consensus Throughput vs. Decentralization}

Local throughput (9M blocks/sec) drops to 3,500 in geographically distributed setting. This is expected due to:
\begin{itemize}
\item Network latency dominates consensus time
\item Snow consensus requires $k=20$ samples per decision
\item Trade-off favors safety over speed
\end{itemize}

\subsubsection{HLLM Complexity}

Physics-inspired routing adds 2.8ms overhead vs. simple random selection. Benefits justify cost:
\begin{itemize}
\item 15-30\% cost reduction via optimal model selection
\item Improved user experience through regime-aware routing
\item Adaptive learning without retraining models
\end{itemize}

\subsection{Future Work}

\subsubsection{SLH-DSA Integration}

SPHINCS+ (SLH-DSA) provides hash-based signatures without lattice assumptions. Future versions will support hybrid ML-DSA/SLH-DSA for algorithm agility.

\subsubsection{Hardware Acceleration}

FPGA/ASIC implementations of ML-KEM could reduce latency to $<$10μs, enabling PQC in ultra-low-latency applications.

\subsubsection{Federated Learning}

Extending HLLM to support decentralized model training across nodes while preserving privacy via secure aggregation.

\subsubsection{Zero-Knowledge Proofs}

zk-SNARKs for verifiable compute execution, enabling trustless verification of inference results without revealing model weights.

\subsection{Limitations}

\begin{enumerate}
\item \textbf{Quantum timeline uncertainty}: PQC overhead may be premature if quantum threat is $>$20 years away.

\item \textbf{HLLM tuning}: Regime detection thresholds require per-deployment tuning; no universal defaults.

\item \textbf{Cross-runtime compatibility}: Not all workloads portable across Docker/K8s/WASM without modification.

\item \textbf{Single-chain scaling}: Current architecture limited to single consensus chain; sharding not yet implemented.
\end{enumerate}

\section{Conclusion}

Hanzo Network demonstrates that decentralized AI compute infrastructure can achieve production-grade performance while providing quantum-safe security guarantees. The integration of HLLM routing, PQC, unified runtime abstraction, and high-throughput consensus creates a platform suitable for real-world AI workloads.

Key results:
\begin{itemize}
\item \textbf{9M+ blocks/second} local consensus throughput
\item \textbf{$<$100μs} PQC operations (ML-KEM-768)
\item \textbf{2.8ms} HLLM routing overhead
\item \textbf{5-tier privacy model} from open to GPU TEE-I/O
\item \textbf{20+ LLM providers} with unified interface
\item \textbf{Native Qwen3 support} at 4096 dimensions
\end{itemize}

The system has been in production since September 2025 with continuous development (4,500+ commits). Future work will focus on federated learning, hardware PQC acceleration, and zero-knowledge compute verification.

\section*{Acknowledgments}

We thank the Open Quantum Safe project for liboqs implementations, the Lux Network team for consensus engine foundations, and the Qwen team for state-of-the-art embedding models. Special thanks to early adopters providing feedback during beta testing.

\bibliographystyle{plain}
\begin{thebibliography}{99}

\bibitem{bitdelta}
Y. Zhou et al., ``BitDelta: Efficient Training-Free Acceleration of Large Language Models,''
\textit{arXiv preprint arXiv:2405.04144}, 2024.

\bibitem{liboqs}
D. Stebila and M. Mosca, ``Post-quantum Key Exchange for the Internet and the Open Quantum Safe Project,''
\textit{International Conference on Selected Areas in Cryptography}, pp. 1-24, 2016.

\bibitem{fips203}
National Institute of Standards and Technology,
``FIPS 203: Module-Lattice-Based Key-Encapsulation Mechanism Standard,''
\url{https://csrc.nist.gov/pubs/fips/203/final}, 2024.

\bibitem{fips204}
National Institute of Standards and Technology,
``FIPS 204: Module-Lattice-Based Digital Signature Standard,''
\url{https://csrc.nist.gov/pubs/fips/204/final}, 2024.

\bibitem{sp80056c}
National Institute of Standards and Technology,
``SP 800-56C Rev. 2: Recommendation for Key-Derivation Methods in Key-Establishment Schemes,''
\url{https://csrc.nist.gov/pubs/sp/800/56/c/r2/final}, 2020.

\bibitem{friston}
K. Friston, ``The Free-Energy Principle: A Unified Brain Theory?''
\textit{Nature Reviews Neuroscience}, vol. 11, no. 2, pp. 127-138, 2010.

\bibitem{snow}
T. Rocket et al., ``Scalable and Probabilistic Leaderless BFT Consensus through Metastability,''
\textit{arXiv preprint arXiv:1906.08936}, 2019.

\bibitem{golem}
Golem Network, ``Golem: Decentralized Computation Platform,''
\url{https://golem.network/}, 2020.

\bibitem{render}
Render Network, ``The Decentralized GPU Rendering Network,''
\url{https://rendernetwork.com/}, 2023.

\bibitem{akash}
Akash Network, ``The Supercloud for AI,''
\url{https://akash.network/}, 2024.

\bibitem{awspqtls}
Amazon Web Services, ``Introducing Post-Quantum TLS,''
AWS Security Blog, 2023.

\bibitem{anyscale}
Anyscale, ``Ray: A Distributed Framework for Emerging AI Applications,''
\url{https://www.anyscale.com/}, 2023.

\bibitem{baseten}
Baseten, ``Fast Model Inference at Any Scale,''
\url{https://www.baseten.co/}, 2024.

\bibitem{azurecc}
Microsoft Azure, ``Azure Confidential Computing,''
\url{https://azure.microsoft.com/en-us/solutions/confidential-compute/}, 2024.

\bibitem{h100cc}
NVIDIA, ``H100 Confidential Computing: Secure AI for the Data Center,''
NVIDIA Technical White Paper, 2024.

\bibitem{qwen3}
Alibaba Cloud, ``Qwen3: Large Language and Multimodal Models,''
\url{https://qwen.io/}, 2025.

\bibitem{luxconsensus}
Lux Partners Inc., ``Lux Consensus: A Multi-Consensus Blockchain Platform,''
Technical Documentation, 2024.

\bibitem{sled}
Spacejam, ``Sled: Modern Embedded Database,''
\url{https://github.com/spacejam/sled}, 2023.

\bibitem{mistrals}
Mistral AI, ``mistral.rs: High-Performance Inference Engine,''
\url{https://github.com/EricLBuehler/mistral.rs}, 2024.

\bibitem{hamiltonianhmm}
S. Särkkä and Á. F. García-Fernández, ``Temporal Parallelization of Bayesian Smoothers,''
\textit{IEEE Transactions on Automatic Control}, vol. 66, no. 1, pp. 299-306, 2020.

\end{thebibliography}

\section*{Version History}

\begin{itemize}
\item \textbf{v2025.09}: Initial public release (September 18, 2025)
  \begin{itemize}
  \item HLLM routing framework
  \item PQC integration (ML-KEM + ML-DSA)
  \item Unified runtime abstraction
  \item Lux consensus integration
  \item Native Qwen3 embeddings
  \end{itemize}
\end{itemize}

\appendix

\section{API Reference}

\subsection{HLLM Routing Endpoint}

\textbf{POST} \texttt{/v1/hllm/route}

Request:
\begin{lstlisting}[language=json]
{
  "user_id": "user_123",
  "input": "Explain quantum computing",
  "context": ["Previous messages..."],
  "preferences": {
    "max_cost_usd": 0.01,
    "min_quality": 0.8
  }
}
\end{lstlisting}

Response:
\begin{lstlisting}[language=json]
{
  "model": "claude-3-opus",
  "regime": "Exploration",
  "efe": -2.34,
  "estimated_cost_usd": 0.008,
  "expected_quality": 0.92
}
\end{lstlisting}

\subsection{PQC Key Establishment}

\textbf{POST} \texttt{/v1/pqc/encapsulate}

Request:
\begin{lstlisting}[language=json]
{
  "encapsulation_key": "base64...",
  "algorithm": "ML-KEM-768",
  "privacy_tier": 2
}
\end{lstlisting}

Response:
\begin{lstlisting}[language=json]
{
  "ciphertext": "base64...",
  "shared_secret_hash": "blake3..."
}
\end{lstlisting}

\subsection{Runtime Deployment}

\textbf{POST} \texttt{/v1/runtime/deploy}

Request:
\begin{lstlisting}[language=json]
{
  "runtime_type": "docker",
  "image": "nginx:latest",
  "replicas": 3,
  "resources": {
    "cpu": 2.0,
    "memory_gb": 4,
    "gpu_count": 0
  },
  "privacy_tier": 1
}
\end{lstlisting}

Response:
\begin{lstlisting}[language=json]
{
  "deployment_id": "dep_abc123",
  "status": "deploying",
  "estimated_cost_per_hour": 0.15,
  "blockchain_tx": "0xabc..."
}
\end{lstlisting}

\section{Configuration Reference}

\subsection{HLLM Configuration}

\texttt{~/.hanzo/hllm.toml}:

\begin{lstlisting}
[hllm]
num_regimes = 4
transition_threshold = 0.15
energy_scale = 1.0
quantization_bits = 1
efe_precision = 0.01
db_path = "./hllm_storage.db"
vector_dim = 768
adapter_cache_size = 100
\end{lstlisting}

\subsection{PQC Configuration}

\texttt{~/.hanzo/pqc.toml}:

\begin{lstlisting}
[pqc]
default_kem = "ML-KEM-768"
default_dsa = "ML-DSA-65"
hybrid_mode = true
fips_mode = false
auto_privacy_tier = true

[kbs]
attestation_required = true
gpu_cc_enabled = true
tee_io_enabled = false
\end{lstlisting}

\subsection{Runtime Configuration}

\texttt{~/.hanzo/runtime.toml}:

\begin{lstlisting}
[runtime]
default_type = "docker"
max_concurrent_deployments = 100

[runtime.docker]
socket = "/var/run/docker.sock"
enable_gpu = true

[runtime.kubernetes]
kubeconfig = "~/.kube/config"
namespace = "hanzo"

[runtime.wasm]
engine = "wasmtime"
cache_size_mb = 512

[metering]
compute_unit_formula = "cpu*10 + mem_gb*5 + gpu*100"
billing_interval_blocks = 100
token_mining_rate = 10.0
validator_commission = 0.10
\end{lstlisting}

\end{document}
